/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.trino.jni;

import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.SettableFuture;
import io.airlift.log.Logger;

import javax.validation.constraints.NotNull;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * This class is instantiated through JNI while the Velox returned future.
 * <p>
 * The SettableFuture inside this class is used by C++. The C++ NativeListenableFuture holds the
 * reference of folly future which is generated by Velox Driver. When folly future has been completed,
 * it will trigger the callback and call this class's methods to make SettableFuture change state.
 * Therefore, make SettableFuture's listener run.
 * <p>
 * Furthermore, the C++ NativeListenableFuture's reference will be released when the SettableFuture's state
 * changes in order to avoid memory leaks.
 */
public class NativeListenableFuture
        implements ListenableFuture<Void>
{
    private static final Logger log = Logger.get(NativeListenableFuture.class);
    private final SettableFuture<Void> future = SettableFuture.create();
    private volatile long nativePointer;

    public NativeListenableFuture(long nativePointer)
    {
        this.nativePointer = nativePointer;
        // NativeListenableFuture in native must be released after finished. The order is not concerned.
        addListener(() -> {
            log.debug("free Java and CPP NativeListenableFuture NativeListenableFuture.");
            freeNative(this.nativePointer);
            this.nativePointer = 0;
        }, Executors.newSingleThreadExecutor());
    }

    // ================ jni methods ================
    private native void freeNative(long nativePointer);

    private native boolean cancelNative(long nativePointer, boolean mayInterruptIfRunning);

    // ================ methods used by native ================
    @SuppressWarnings("unused")
    void setValue()
    {
        future.set(null);
    }

    @SuppressWarnings("unused")
    void setException(Throwable t)
    {
        future.setException(t);
    }

    // ================ java methods ================
    @Override
    public void addListener(@NotNull Runnable listener, @NotNull Executor executor)
    {
        future.addListener(listener, executor);
    }

    @Override
    public boolean cancel(boolean mayInterruptIfRunning)
    {
        boolean canceled = cancelNative(nativePointer, mayInterruptIfRunning);
        // must cancel native before.
        future.cancel(mayInterruptIfRunning);
        return canceled;
    }

    @Override
    public boolean isCancelled()
    {
        return future.isCancelled();
    }

    @Override
    public boolean isDone()
    {
        return future.isDone();
    }

    @Override
    public Void get() throws InterruptedException, ExecutionException
    {
        return future.get();
    }

    @Override
    public Void get(long timeout, @NotNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException
    {
        return future.get(timeout, unit);
    }
}
